import { RulesController } from "./rules.controller";
import { UpdateController } from "./update.controller";
import { HttpClientController } from "./http-client.controller";
import { AuthController } from "./auth.controller";
import { DatabaseChangesController } from "./database-changes.controller";
export declare enum QueryOrder {
    ASCENDING = "asc",
    DESCENDING = "desc"
}
export declare class QueryController {
    private readonly domain;
    private readonly httpClientController;
    private readonly rulesController;
    private readonly authController;
    private readonly appName;
    private query;
    constructor(domain: string, httpClientController: HttpClientController, rulesController: RulesController, authController: AuthController, appName: string);
    orderBy(field: string, value?: 'asc' | 'desc'): QueryController;
    cids(value: boolean): this;
    byId(id: string): QueryController;
    count(countQuery?: boolean): QueryController;
    size(size: number): QueryController;
    skip(skip: number): QueryController;
    equalTo(field: string, value: any): QueryController;
    hashes(localDataHashes: string[]): QueryController;
    notEqualTo(field: string, value: any): QueryController;
    greaterThan(field: string, value: any): QueryController;
    greaterThanOrEqual(field: string, value: any): QueryController;
    includesIn(field: string, value: any[]): QueryController;
    notIncludesIn(field: string, value: any[]): QueryController;
    lessThan(field: string, value: any): QueryController;
    lessThanOrEqual(field: string, value: any): QueryController;
    exists(field: string): QueryController;
    searchByRegex(field: string, regex: string, flags?: string): QueryController;
    raw(query: any, options?: RequestOptions): Promise<any[]>;
    private buildQuery;
    delete<T>(options?: RequestOptions): Promise<T>;
    updateBuilder(): UpdateController;
    changes(onConnect?: () => void, onDisconnect?: () => void, options?: RequestOptions): DatabaseChangesController;
    find<T>(options?: RequestOptions): Promise<T>;
    queryRuleRequest(queryRule: any): Promise<any>;
    private static parseFnValue;
}
export interface RequestOptions extends CacheOptions {
    useMasterKey?: boolean;
    returnFields?: string[];
    skip?: number;
    limit?: number;
}
export interface FileOptions extends RequestOptions {
    pn?: boolean;
    filename?: string;
}
interface CacheOptions {
    /**
     * enable cache in method level, override global option
     */
    cacheEnable?: boolean;
    /**
     * cache to expire flag
     */
    dtl?: number;
    /**
     * callback to response from network data, just before that data is updated to cache
     * @param identifier {string} cache identifier
     * @param data {T extend object} fresh data from network
     // * @deprecated use #onUpdated
     */
    freshDataCallback?: <T>(value: {
        identifier: string;
        data: T;
    }) => void;
}
export {};
