var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SocketController } from "./socket.controller";
import { UpdateController } from "./update.controller";
import { DatabaseChangesController } from "./database-changes.controller";
import { extractResultFromServer } from "../utils/data.util";
import { getConfig } from '../bfast';
export var QueryOrder;
(function (QueryOrder) {
    QueryOrder["ASCENDING"] = "asc";
    QueryOrder["DESCENDING"] = "desc";
})(QueryOrder || (QueryOrder = {}));
export class QueryController {
    constructor(domain, httpClientController, rulesController, authController, appName) {
        this.domain = domain;
        this.httpClientController = httpClientController;
        this.rulesController = rulesController;
        this.authController = authController;
        this.appName = appName;
        this.query = {
            id: undefined,
            filter: {},
            return: [],
            skip: 0,
            hashes: [],
            cids: false,
            orderBy: [{ 'createdAt': -1 }],
            count: false,
        };
    }
    orderBy(field, value = 'asc') {
        var _a;
        let _value = 1;
        if (value === "asc") {
            _value = 1;
        }
        if (value === "desc") {
            _value = -1;
        }
        // if (this?.query?.filter[field]?.$fn) {
        //     Object.assign(this.query.filter[field], {
        //         $orderBy: value
        //     });
        // } else {
        //     Object.assign(this.query.filter, {
        //         [field]: {
        //             $fn: 'return true',
        //             $orderBy: value
        //         }
        //     });
        // }
        // if (typeof options?.limit === "number"){
        //     Object.assign(this.query.filter[field], {
        //         $limit: options.limit
        //     });
        // }
        // if (typeof options?.skip === "number"){
        //     Object.assign(this.query.filter[field], {
        //         $skip: options.skip
        //     });
        // }
        // return this.find(options);
        (_a = this.query.orderBy) === null || _a === void 0 ? void 0 : _a.push({ [field]: _value });
        return this;
    }
    cids(value) {
        this.query.cids = value;
        return this;
    }
    byId(id) {
        this.query.id = id;
        return this;
    }
    count(countQuery = false) {
        this.query.count = countQuery;
        return this;
    }
    size(size) {
        this.query.size = size;
        return this;
    }
    skip(skip) {
        this.query.skip = skip;
        return this;
    }
    equalTo(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $eq: value
        });
        return this;
    }
    hashes(localDataHashes) {
        Object.assign(this.query, {
            hashes: localDataHashes
        });
        return this;
    }
    notEqualTo(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $ne: value
        });
        return this;
    }
    greaterThan(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $gt: value
        });
        return this;
    }
    greaterThanOrEqual(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $gte: value
        });
        return this;
    }
    includesIn(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $in: value
        });
        return this;
    }
    notIncludesIn(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $nin: value
        });
        return this;
    }
    lessThan(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $lt: value
        });
        return this;
    }
    lessThanOrEqual(field, value) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $lte: value
        });
        return this;
    }
    exists(field) {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $exists: true
        });
        return this;
    }
    searchByRegex(field, regex, flags = 'ig') {
        if (!this.query.filter.hasOwnProperty(field)) {
            this.query.filter[field] = {};
        }
        Object.assign(this.query.filter[field], {
            $regex: regex,
            $options: flags
        });
        return this;
    }
    // fullTextSearch(field: string, text: string, flags = 'ig'): QueryController {
    //     Object.assign(this.query.filter, {
    //         [field]: {
    //             $fn: `return it?.toString()?.match(new RegExp(${text}, ${flags})) !== null;`
    //         }
    //     });
    //     return this;
    // }
    raw(query, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.query.filter = query;
            return this.find(options);
        });
    }
    buildQuery() {
        return this.query;
    }
    delete(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const credential = getConfig().credential(this.appName);
            const deleteRule = yield this.rulesController.deleteRule(this.domain, this.buildQuery(), credential, options);
            const response = yield this.httpClientController.post(getConfig().databaseURL(this.appName), deleteRule, {
                headers: {}
            }, {
                context: this.domain,
                rule: `delete${this.domain}`,
                type: 'daas',
                token: yield this.authController.getToken()
            });
            return extractResultFromServer(response.data, 'delete', this.domain);
        });
    }
    updateBuilder() {
        return new UpdateController(this.domain, this.buildQuery(), this.appName, this.httpClientController, this.rulesController, this.authController);
    }
    changes(onConnect, onDisconnect, options = { useMasterKey: false }) {
        const applicationId = getConfig().credential(this.appName).applicationId;
        const projectId = getConfig().credential(this.appName).projectId;
        const masterKey = getConfig().credential(this.appName).appPassword;
        let match;
        if (this.buildQuery() && typeof this.buildQuery().filter === "object") {
            match = this.buildQuery().filter;
            Object.keys(match).forEach(key => {
                match[`fullDocument.${key}`] = match[key];
                delete match[key];
            });
        }
        const socketController = new SocketController('/v2/__changes__', this.appName, () => {
            if (onConnect && typeof onConnect === "function") {
                onConnect();
            }
            socketController.emit({
                auth: {
                    applicationId: applicationId,
                    topic: `${projectId}_${this.domain}`,
                    masterKey: options.useMasterKey === true ? masterKey : null
                },
                body: {
                    domain: this.domain, pipeline: []
                }
            });
        }, onDisconnect);
        return new DatabaseChangesController(socketController);
    }
    find(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryRule = yield this.rulesController.queryRule(this.domain, this.buildQuery(), getConfig().credential(this.appName), options);
            return this.queryRuleRequest(queryRule);
        });
    }
    queryRuleRequest(queryRule) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.httpClientController.post(getConfig().databaseURL(this.appName), queryRule, {}, {
                context: this.domain,
                rule: `query${this.domain}`,
                type: 'daas',
                token: yield this.authController.getToken()
            });
            const data = response.data;
            if (data && data[`query${this.domain}`] !== undefined) {
                return data[`query${this.domain}`];
            }
            else {
                const errors = data.errors;
                let queryError = { message: "Query not succeed" };
                Object.keys(errors && typeof errors === "object" ? errors : {}).forEach(value => {
                    if (value.includes('query')) {
                        queryError = errors[value];
                    }
                });
                queryError['errors'] = errors;
                throw queryError;
            }
        });
    }
    static parseFnValue(value) {
        let parsed = '';
        switch (typeof value) {
            case "string":
                parsed = `'${value}'`;
                break;
            case "number":
                parsed = `${value}`;
                break;
            case "object":
                parsed = `JSON.parse('${JSON.stringify(value)}')`;
                break;
            default:
                return parsed;
        }
        return parsed;
    }
}
