var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
export class RulesController {
    constructor() {
    }
    createRule(domain, data, appCredential, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const createRule = {};
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(createRule, {
                    masterKey: appCredential.appPassword
                });
            }
            Object.assign(createRule, {
                applicationId: appCredential.applicationId
            });
            if (data !== null && data !== undefined) {
                if (Array.isArray(data)) {
                    data.map(x => {
                        x.return = (options === null || options === void 0 ? void 0 : options.returnFields) ? options.returnFields : [];
                        return x;
                    });
                }
                else {
                    data.return = (options === null || options === void 0 ? void 0 : options.returnFields) ? options.returnFields : [];
                }
                Object.assign(createRule, {
                    [`create${domain}`]: data
                });
                return this.addToken(createRule);
            }
            else {
                throw { message: 'please provide data to save' };
            }
        });
    }
    deleteRule(domain, query, appCredential, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const deleteRule = {};
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(deleteRule, {
                    masterKey: appCredential.appPassword
                });
            }
            Object.assign(deleteRule, {
                applicationId: appCredential.applicationId,
                [`delete${domain}`]: query
            });
            return this.addToken(deleteRule);
        });
    }
    updateRule(domain, query, updateModel, upsert, appCredential, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const updateRule = {};
            if (options && options.useMasterKey === true) {
                Object.assign(updateRule, {
                    masterKey: appCredential.appPassword
                });
            }
            query.return = (options === null || options === void 0 ? void 0 : options.returnFields) ? options.returnFields : [];
            query.upsert = upsert;
            query.update = updateModel;
            Object.assign(updateRule, {
                applicationId: appCredential.applicationId,
                [`update${domain}`]: query
            });
            return this.addToken(updateRule);
        });
    }
    updateManyRule(domain, payload, appCredential, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const updateRule = {};
            if (options && options.useMasterKey === true) {
                Object.assign(updateRule, {
                    masterKey: appCredential.appPassword
                });
            }
            Object.assign(updateRule, {
                applicationId: appCredential.applicationId
            });
            const updateRequests = payload.map(value => {
                value.query.return = (options === null || options === void 0 ? void 0 : options.returnFields) ? options.returnFields : [];
                Object.assign(value.query, {
                    update: value.update
                });
                return value.query;
            });
            Object.assign(updateRule, {
                [`update${domain}`]: updateRequests
            });
            return this.addToken(updateRule);
        });
    }
    aggregateRule(domain, pipeline, appCredentials, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const aggregateRule = {};
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(aggregateRule, {
                    'masterKey': appCredentials.appPassword
                });
            }
            Object.assign(aggregateRule, {
                applicationId: appCredentials.applicationId,
                [`aggregate${domain}`]: pipeline
            });
            return this.addToken(aggregateRule);
        });
    }
    queryRule(domain, queryModel, appCredentials, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryRule = {};
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(queryRule, {
                    'masterKey': appCredentials.appPassword
                });
            }
            queryModel.return = (options === null || options === void 0 ? void 0 : options.returnFields) ? options.returnFields : [];
            Object.assign(queryRule, {
                applicationId: appCredentials.applicationId,
                [`query${domain}`]: queryModel
            });
            return this.addToken(queryRule);
        });
    }
    bulk(transactions, appCredentials, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const transactionRule = {
                transaction: {
                    commit: {}
                }
            };
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(transactionRule, {
                    masterKey: appCredentials.appPassword
                });
            }
            Object.assign(transactionRule, {
                applicationId: appCredentials.applicationId,
            });
            for (const value of transactions) {
                if (value.action === "create") {
                    const createRule = yield this.createRule(value.domain, value.data, appCredentials, options);
                    Object.assign(transactionRule.transaction.commit, {
                        [`${value.action}${value.domain}`]: createRule[`${value.action}${value.domain}`]
                    });
                }
                else if (value.action === "update") {
                    if (value.data && Array.isArray(value.data)) {
                        const updateRule = yield this.updateManyRule(value.domain, value.data, appCredentials, options);
                        Object.assign(transactionRule.transaction.commit, {
                            [`${value.action}${value.domain}`]: updateRule[`${value.action}${value.domain}`]
                        });
                    }
                    else if (value.data && value.data.query && value.data.update) {
                        const updateRule = yield this.updateRule(value.domain, value.data.query, value.data.update, value.data.upsert, appCredentials, options);
                        Object.assign(transactionRule.transaction.commit, {
                            [`${value.action}${value.domain}`]: updateRule[`${value.action}${value.domain}`]
                        });
                    }
                }
                else if (value.action === "delete" && value.data && value.data.query) {
                    const deleteQuery = yield this.deleteRule(value.domain, value.data.query, appCredentials, options);
                    Object.assign(transactionRule.transaction.commit, {
                        [`${value.action}${value.domain}`]: deleteQuery[`${value.action}${value.domain}`]
                    });
                }
            }
            return this.addToken(transactionRule);
        });
    }
    storage(action, payload, appCredentials, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const storageRule = {};
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(storageRule, {
                    'masterKey': appCredentials.appPassword
                });
            }
            Object.assign(storageRule, {
                applicationId: appCredentials.applicationId,
                files: {
                    [action]: payload
                }
            });
            return this.addToken(storageRule);
        });
    }
    addToken(rule) {
        return __awaiter(this, void 0, void 0, function* () {
            // const token = await this.authController.getToken();
            // Object.assign(rule, {
            //     token
            // });
            return rule;
        });
    }
}
