var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BFastConfig } from "../conf";
import { isBrowserLike } from "../utils/platform.util";
// @ts-ignore
import FormData from 'form-data';
import { getConfig } from "../bfast";
export class StorageController {
    constructor(httpClientController, auth, rulesController, authController, appName = BFastConfig.DEFAULT_APP) {
        this.httpClientController = httpClientController;
        this.auth = auth;
        this.rulesController = rulesController;
        this.authController = authController;
        this.appName = appName;
    }
    save(file, uploadProgress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!isBrowserLike) {
                try {
                    if (file && file.filename && file.data) {
                        return this._handleFileUploadInNode(file, uploadProgress, getConfig().credential(this.appName), options);
                    }
                    else {
                        throw new Error('file object to save is invalid, data and filename is required field');
                    }
                }
                catch (e) {
                    console.log(e);
                    throw e;
                }
            }
            else {
                if (file && file.data && file.data instanceof File && file.filename) {
                    return this._handleFileUploadInWeb(file, uploadProgress, getConfig().credential(this.appName), options);
                }
                else {
                    throw new Error('file object to save is invalid, data and filename is required field');
                }
            }
        });
    }
    list(query = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const filesRule = yield this.rulesController.storage("list", query, getConfig().credential(this.appName), options);
            return this._handleFileRuleRequest(filesRule, 'list');
        });
    }
    getUrl(filename) {
        const config = getConfig();
        return `${config.databaseURL(this.appName, '')}/storage/${config.credential(this.appName).applicationId}/file/${filename}`;
    }
    delete(filename, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const filesRule = yield this.rulesController.storage("delete", { filename }, getConfig().credential(this.appName), options);
            return this._handleFileRuleRequest(filesRule, 'delete');
        });
    }
    _handleFileRuleRequest(storageRule, action) {
        return __awaiter(this, void 0, void 0, function* () {
            const credential = getConfig().credential(this.appName);
            const response = yield this.httpClientController.post(getConfig().databaseURL(this.appName), storageRule, {
                headers: {
                    'x-bfast-application-id': credential.applicationId
                }
            }, {
                context: '_Storage',
                rule: 'storage',
                type: 'daas',
                token: yield this.authController.getToken()
            });
            const data = response.data;
            if (data && data.files && data.files.list && Array.isArray(data.files.list)) {
                return data.files.list;
            }
            else {
                const errors = data.errors;
                throw errors && errors[`files.${action}`] ? errors[`files.${action}`] : {
                    message: 'Fails to process your request',
                    errors
                };
            }
        });
    }
    _fileUploadRequest(formData, headers, applicationId, progress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = {};
            Object.assign(query, {
                pn: options.pn ? options.pn : false,
            });
            if (options.filename) {
                Object.assign(query, {
                    filename: options.filename
                });
            }
            return this.httpClientController.post(getConfig().databaseURL(this.appName, '/storage/' + applicationId), formData, {
                onUploadProgress: progress,
                headers,
                params: query
            }, {
                context: '_Storage',
                rule: 'storage',
                type: 'daas',
                token: yield this.authController.getToken()
            });
        });
    }
    _handleFileUploadInNode(file, uploadProgress, appCredentials, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(headers, {
                    'masterKey': appCredentials.appPassword
                });
            }
            const token = yield this.auth.getToken();
            const formData = new FormData();
            formData.append('file', file.data, {
                filename: file.filename
            });
            Object.assign(headers, Object.assign({ 'Authorization': `Bearer ${token}` }, formData.getHeaders()));
            options.pn = file.pn;
            options.filename = file.filename;
            const response = yield this._fileUploadRequest(formData, headers, appCredentials.applicationId, uploadProgress, options);
            let databaseUrl = getConfig().databaseURL(this.appName, '');
            return databaseUrl + response.data.urls[0];
        });
    }
    _handleFileUploadInWeb(file, uploadProgress, appCredentials, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (options && (options === null || options === void 0 ? void 0 : options.useMasterKey) === true) {
                Object.assign(headers, {
                    'masterKey': appCredentials.appPassword
                });
            }
            const token = yield this.auth.getToken();
            Object.assign(headers, {
                'Authorization': `Bearer ${token}`
            });
            const formData = new FormData();
            formData.append('file', file.data, file.filename);
            options.pn = file.pn;
            options.filename = file.filename;
            const response = yield this._fileUploadRequest(formData, headers, appCredentials.applicationId, uploadProgress, options);
            let databaseUrl = getConfig().databaseURL(this.appName, '');
            return databaseUrl + response.data.urls[0];
        });
    }
}
