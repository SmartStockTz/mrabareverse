var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getConfig } from '../bfast';
export class AggregateController {
    constructor(domain, httpClientController, rulesController, authController, appName) {
        this.domain = domain;
        this.httpClientController = httpClientController;
        this.rulesController = rulesController;
        this.authController = authController;
        this.appName = appName;
        this.aggregateModel = {
            hashes: [],
            pipelines: []
        };
    }
    hashes(localDataHashes) {
        Object.assign(this.aggregateModel, {
            hashes: localDataHashes
        });
        return this;
    }
    stage(stage) {
        const _set = new Set(this.aggregateModel.pipelines);
        _set.add(stage);
        Object.assign(this.aggregateModel, {
            pipelines: Array.from(_set)
        });
        return this;
    }
    find(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const aggregateRule = yield this.rulesController.aggregateRule(this.domain, this.aggregateModel, getConfig().credential(this.appName), options);
            return this.aggregateRuleRequest(aggregateRule);
        });
    }
    aggregateRuleRequest(pipelineRule) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.httpClientController.post(getConfig().databaseURL(this.appName), pipelineRule, {}, {
                context: this.domain,
                rule: `aggregate${this.domain}`,
                type: 'daas',
                token: yield this.authController.getToken()
            });
            const data = response.data;
            if (data && data[`aggregate${this.domain}`]) {
                return data[`aggregate${this.domain}`];
            }
            else {
                const errors = data.errors;
                let aggregateError = { message: "Aggregation not succeed" };
                Object.keys(errors).forEach(value => {
                    if (value.includes('aggregate')) {
                        aggregateError = errors[value];
                    }
                });
                aggregateError['errors'] = errors;
                throw aggregateError;
            }
        });
    }
}
